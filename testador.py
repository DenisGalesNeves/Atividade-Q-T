# -*- coding: utf-8 -*-
"""Testador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZGnKI8O609ajSOcEIqFufv2D7Wf7N9kt

# **Teste para maiores de 18!**
"""

def validar_idade(idade):
    """
    Valida se a idade √© maior ou igual a 18 anos

    Args:
        idade (int): Idade a ser validada

    Returns:
        bool: True se idade >= 18, False caso contr√°rio

    Raises:
        ValueError: Se a idade n√£o for um n√∫mero inteiro
    """
    if not isinstance(idade, int):
        raise ValueError("A idade deve ser um n√∫mero inteiro")

    return idade >= 18

import unittest

class TestValidadorIdade(unittest.TestCase):

    def test_idade_maior_18(self):
        """Testa idades maiores ou iguais a 18 anos"""
        self.assertTrue(validar_idade(18))    # Limite inferior
        self.assertTrue(validar_idade(25))    # Maior que 18
        self.assertTrue(validar_idade(100))   # Idade avan√ßada
        self.assertTrue(validar_idade(30))    # Adulto
        self.assertTrue(validar_idade(21))    # Maioridade em alguns pa√≠ses

    def test_tipo_invalido(self):
        """Testa se levanta exce√ß√£o para tipos inv√°lidos"""
        with self.assertRaises(ValueError):
            validar_idade("18")      # String
        with self.assertRaises(ValueError):
            validar_idade(18.5)      # Float
        with self.assertRaises(ValueError):
            validar_idade([18])      # Lista
        with self.assertRaises(ValueError):
            validar_idade(None)      # None

    def test_casos_limite_positivos(self):
        """Testa casos limite positivos"""
        self.assertTrue(validar_idade(18))
        self.assertTrue(validar_idade(20))
        self.assertTrue(validar_idade(22))

# Fun√ß√£o para verifica√ß√£o interativa
def verificar_idade_interativo():
    """Fun√ß√£o para digitar e verificar a idade"""
    print("\n" + "="*50)
    print("VERIFICA√á√ÉO INTERATIVA DE IDADE")
    print("="*50)

    while True:
        try:
            # Digitar a idade
            entrada = input("\nDigite sua idade (ou 'sair' para terminar): ")

            if entrada.lower() == 'sair':
                print("Encerrando verifica√ß√£o...")
                break

            # Converter para inteiro e validar
            idade = int(entrada)
            resultado = validar_idade(idade)

            # Mostrar resultado
            if resultado:
                print(f"‚úì Com {idade} anos: MAIOR DE IDADE")
            else:
                print(f"‚úó Com {idade} anos: MENOR DE IDADE")

        except ValueError:
            print("‚ùå Erro: Digite apenas n√∫meros inteiros!")
        except Exception as e:
            print(f"‚ùå Erro inesperado: {e}")

# Executar os testes
if __name__ == '__main__':
    # Primeiro executamos os testes unit√°rios
    print("EXECUTANDO TESTES UNIT√ÅRIOS...")
    print("="*50)

    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(TestValidadorIdade)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    # Mostrar resultado dos testes
    print(f"\n{'='*50}")
    print(f"Resultado dos testes: {'SUCESSO' if result.wasSuccessful() else 'FALHA'}")
    print(f"Testes executados: {result.testsRun}")
    print(f"Falhas: {len(result.failures)}")
    print(f"Erros: {len(result.errors)}")
    print(f"{'='*50}")

    # Depois executamos a verifica√ß√£o interativa
    verificar_idade_interativo()

"""# **Teste de Impar e Par**"""

def verificar_par_impar(numero):
    """
    Verifica se um n√∫mero √© par ou √≠mpar

    Args:
        numero (int): N√∫mero a ser verificado

    Returns:
        str: 'par' se o n√∫mero for par, '√≠mpar' caso contr√°rio

    Raises:
        ValueError: Se o n√∫mero n√£o for um inteiro
    """
    if not isinstance(numero, int):
        raise ValueError("O n√∫mero deve ser um inteiro")

    return 'par' if numero % 2 == 0 else '√≠mpar'

import unittest

class TestVerificarParImpar(unittest.TestCase):

    def test_numeros_pares(self):
        """Testa n√∫meros pares positivos"""
        self.assertEqual(verificar_par_impar(0), 'par')     # Zero √© par
        self.assertEqual(verificar_par_impar(2), 'par')     # Par pequeno
        self.assertEqual(verificar_par_impar(10), 'par')    # Par m√©dio
        self.assertEqual(verificar_par_impar(100), 'par')   # Par grande
        self.assertEqual(verificar_par_impar(-4), 'par')    # Par negativo

    def test_numeros_impares(self):
        """Testa n√∫meros √≠mpares"""
        self.assertEqual(verificar_par_impar(1), '√≠mpar')     # √çmpar pequeno
        self.assertEqual(verificar_par_impar(7), '√≠mpar')     # √çmpar m√©dio
        self.assertEqual(verificar_par_impar(99), '√≠mpar')    # √çmpar grande
        self.assertEqual(verificar_par_impar(-3), '√≠mpar')    # √çmpar negativo

    def test_tipos_invalidos(self):
        """Testa se levanta exce√ß√£o para tipos inv√°lidos"""
        with self.assertRaises(ValueError):
            verificar_par_impar("5")        # String
        with self.assertRaises(ValueError):
            verificar_par_impar(3.14)       # Float
        with self.assertRaises(ValueError):
            verificar_par_impar([2])        # Lista
        with self.assertRaises(ValueError):
            verificar_par_impar(None)       # None

    def test_casos_limite(self):
        """Testa casos limite interessantes"""
        self.assertEqual(verificar_par_impar(0), 'par')      # Zero
        self.assertEqual(verificar_par_impar(1), '√≠mpar')    # Primeiro positivo
        self.assertEqual(verificar_par_impar(-1), '√≠mpar')   # Primeiro negativo
        self.assertEqual(verificar_par_impar(2), 'par')      # Primeiro par positivo

# Fun√ß√£o para verifica√ß√£o interativa
def verificar_numero_interativo():
    """Fun√ß√£o para digitar e verificar se o n√∫mero √© par ou √≠mpar"""
    print("\n" + "="*60)
    print("üîç VERIFICADOR DE N√öMERO PAR OU √çMPAR")
    print("="*60)

    while True:
        try:
            # Digitar o n√∫mero
            entrada = input("\nDigite um n√∫mero inteiro (ou 'sair' para terminar): ")

            if entrada.lower() == 'sair':
                print("Encerrando verifica√ß√£o...")
                break

            # Converter para inteiro e verificar
            numero = int(entrada)
            resultado = verificar_par_impar(numero)

            # Mostrar resultado com emojis
            if resultado == 'par':
                print(f"‚úÖ O n√∫mero {numero} √© PAR!")
            else:
                print(f"üî∂ O n√∫mero {numero} √© √çMPAR!")

        except ValueError as e:
            if "invalid literal" in str(e):
                print("‚ùå Erro: Digite apenas n√∫meros inteiros!")
            else:
                print(f"‚ùå Erro: {e}")
        except Exception as e:
            print(f"üí• Erro inesperado: {e}")

# Executar os testes e verifica√ß√£o interativa
if __name__ == '__main__':
    # Primeiro executamos os testes unit√°rios
    print("EXECUTANDO TESTES UNIT√ÅRIOS...")
    print("="*50)

    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(TestVerificarParImpar)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    # Mostrar resultado dos testes
    print(f"\n{'='*50}")
    print(f"Resultado dos testes: {'‚úÖ SUCESSO' if result.wasSuccessful() else '‚ùå FALHA'}")
    print(f"Testes executados: {result.testsRun}")
    print(f"Falhas: {len(result.failures)}")
    print(f"Erros: {len(result.errors)}")
    print(f"{'='*50}")

    # Depois executamos a verifica√ß√£o interativa
    verificar_numero_interativo()